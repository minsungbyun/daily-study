### 메서드(method) = 함수 (function)

static 은 static 변수끼리 쓸 수 있다

메서드 -명령어(소스코드)를 관리하기 쉽게 기능 단위로 묶어놓은 블럭
```
int plus(int a,b) {
    int sum = a + b;
    return sum;
}
```
[메서드 정의 (method definition)]
plus - 메서드 명
a,b - 파라미터(parameter)
int - 리턴 타입
{} - 메서드 몸체 (method body)

```
int result = plus(100,200);
```
[메서드 호출(method call)]
plus - 메서드 명
100,200 = 아규먼트 (argument);
result - 리턴값을 받을 변수

## 메서드 문법
[리턴값의 타입] 함수명(파라미터선언, ...) {명령어들}
- 리턴 값(return value)의 타입?
=> 함수 블록에 들어있는 명령어를 수행 완료한 후 
   그 결과로 놓이는 값의 타입.
- 파라미터(parameter) 선언?
=> 함수 블록을 실행할 때 외부로부터 받은 값을 저장할 변수 선언.

1) 명령어 블록을 실행할 때 값을 넘겨주지 않고 결과도 넘겨 받지 않는다.
void 메서드명() {
문장1;
문장2;
}

2) 명령어 블록을 실행할 때 값을 넘겨준다. 그러나 결과는 받지 않는다.
void 메서드명(변수선언1, 변수선언2, ...) {
문장1;
문장2;
}

3) 명령어 블록을 실행할 때 값을 넘겨주지 않는다. 결과는 받는다.
리턴타입 메서드명() {
문장1;
문장2;
}

4) 명령어 블록을 실행할 때 값을 넘겨주고 결과를 받는다.
리턴타입 메서드명(변수선언1, 변수선언2, ...) {
문장1;
문장2;
}

## 메서드를 사용하는 방법
[리턴값을 받을 변수] = 메서드명(아규먼트);
- 아규먼트(argument)?
  => 메서드 블록에 들어 있는 명령을 실행하기 위해 넘겨주는 값
  => 즉 파라미터 변수에 넘겨주는 값
  => 파라미터 변수의 타입과 개수와 순서에 맞게 값을 넘겨줘야 한다.
     만약 변수의 타입과 값의 타입이 다르면 컴파일 오류!
     만약 변수의 개수와 값의 개수가 다르면 컴파일 오류!
     변수 선언 순서와 값의 순서가 다르면 컴파일 오류!

- 리턴값을 받을 변수
  => 메서드 블록을 실행한 후 리턴되는 값을 받을 변수이다.
  => 메서드가 값을 리턴한다 하더라도 값을 받기 싫으면
     변수를 선언하지 않아도 된다.
     그러면 리턴 되는 값은 버려진다.
  => 값을 리턴하지 않는 메서드에 대해 변수를 선언하면 컴파일 오류!

파라미터의 타입, 개수, 순서가 일치해야 한다.

# 메서드 활용
- 메서드가 리턴한 값을 한 번만 사용할 경우 쓸데없이 로컬 임시 변수를 만들지 않는다. 사용할 곳에 바로 메서드 호출 코드를 둔다.
```
static void hello(){
    sysout("Hello");
}
System.out.println(hello());
```

- 앞의 예제와 마찬가지로 리턴값을 한번만 사용한다면, 사용할 곳에 메서드 호출 코드를 둬라
    리팩토링 기법 중에서 "replace temp with query"라고 부른다.
```
static String hello(String name, int age) {
     String retVal = String.format("%d살 %s님을 환영합니다!", age, name);
    return retVal;
     }

System.out.println(hello("홍길동",20));
```

# 가변 파라미터
[리턴타입] 메서드명 (타입 ... 변수){...}
0개 이상의 값을 받을 때 선언하는 방식
메서드 내부에서 배열처럼 사용한다.
```
static void hello(String... names){
    for (int i =0; i <names.length; i++) {
        Sysout("%s님 반갑습니다.\n");
    }
}
hello("홍길동", "임꺽정", "방우주")
```
이 경우 세개의 문자열이 저장되어 print 된다.
가변 파라미터 자리에 배열을 직접 넣어도 된다.
```
String[] arr = {"홍길동", "임꺽정", "방우주"};
```
다른 데이터 타입을 입력할 수 없다.
가변 파라미터는 변수 선언 맨 끝에 와야한다.


# 배열 파라미터
```
static void hello2(String[] names) {
 for (int i = 0; i < names.length; i++) {
  System.out.printf("%s님 반갑습니다.\n", names[i]);
 }
}
```
배열 파라미터의 메서드를 호출할 때는
=> 가변 파라미터와 달리 낱개의 값을 여러 개 줄 수 없다!
오직 배열에 담아서 전달해야 한다.
```
String[] arr2 = {"김구", "안중근", "윤봉길", "유관순"};
hello2(arr2);
```
가변 파라미터는
하나의 파라미터에 여러 배열을 선언할 수 없다.

배열 파라미터는
하나의 파라미터에 여러 배열을 선언할 수 있다.


% 배열은 변수가 아니기 때문에 return 을 할수 없어 파라미터 선언시 void 형식을 쓴다.


## 메서드 호출
메서드 호출하는 문장은 가장 안쪽부터 실행된다.

## 메서드 호출과 메모리
- JVM은  main 메서드를 호출했을 때 Method Area, JVM Stack, Heap 세 곳으로 메모리는 나눈다.
    Method Area : 자바코드를 두는 영역, .class 파일의 내용 .class code, 상수, 클래스 변수
    Heap : new 명령으로 생성하는 변수(보통 인스턴스라고 부르는 값)를 둔다.
    JVM Stack : 메서드를 호출할 때 생성되는 로컬 변수를 둔다.
    1. 하드디스크에 존재하는 class파일을 Method Area에 로딩한다.
        class파일을 실행하려면 하드디스크의 class파일을 메모리의 형태(RAM)로 가져와야한다.
        RAM으로 가져오는 그 과정을 loading 이라고 한다.
    2. main() 호출
    3. main()의 로컬변수를 JVM Stack에 생성한다.
    4. Method Area에서 swap()을 호출한다.
    5. JVM Stack에서 swap()이 사용할 로컬변수 준비
    6. 아규먼트 저장 
- 메서드 실행이 끝나면 그 메서드를 호출할 때 생성했던 프레임이 (JVM에 저장됐던 로컬 변수는) 사라진다.

## 로컬변수, 파라미터
로컬변수 - 메서드가 호출될 때 생성되는 변수 (JVM Stack에 저장됨)
파라미터 - 메서드가 호출될 때 값을 넘겨받는 변수
파라미터 ⊂ 로컬변수





