### 비트 이동 연산자 : >> , >>> , <<

## << 0[        0] 
숫자 만큼 왼쪽으로 넘어간다. 넘어간 비트는 제거, 빈자리는 0으로 채운다.
1비트 왼쪽으로 이동할 때 마다 *2한 것과 같다.
음수를 왼쪽으로 이동할 때 부호비트에 상관없이 무조건 이동 -> 뒤에 숫자가 0이라면 양수가 된다.

## >> [0       ]0
숫자 만큼 오른쪽으로 넘어간다. 넘어간 비트는 제거, 빈자리는 부호비트로 채운다.
ㄴ 양수라면 0으로 채우고, 음수라면 1로 채워진다.
1비트 오른쪽으로 이동할 때 마다 /2한 것과 같다.

## >>> [0             ]0
숫자 만큼 오른쪽으로 넘어간다. 넘어간 비트는 제거, 빈자리는 무조건 0으로 채운다.
음수의 기호는 양수로 바뀌는 문제가 발생한다.
1비트 오른쪽으로 이동할 때 마다 /2한 것과 같다.


왼쪽 이동
- 1비트 이동은 곱하기 2 한 것과 같은 효과를 준다.
- 값을 배수로 증가시킬 때 곱하기 연산을 하는 것 보다
왼쪽 비트 이동 연산을 하는 것이 빠르기 때문에
실무에서는 이 비트 이동 연산을 자주 사용한다.
- 비트 이동 => '2**이동비트'를 곱한 것과 같은 결과를 만든다.

int 값에 대해 비트이동 할 때 0 ~ 31비트 까지만 유효하다.
31을 넘는 경우 32로 나눈 나머지 값을 비트이동으로 간주한다.

long일때는 63비트 까지 이동할 수 있다.
63비트를 넘는 경우 64로 나눈 나머지 값을 비트이동으로 간주한다.

오른쪽 이동
- 1비트 이동은 나누기 2 한 것과 같은 효과를 준다.
- 예) n에 대해 x비트를 오른쪽으로 이동 = n / 2**x
- 소수점이 있는 경우 그 수 보다 작은 바로 밑 정수 값이 된다.
- 나누기 연산을 수행하는 것 보다 계산 속도가 빠르다.
실무에서는 나눗셈 연산이 비용(시간과 CPU 사용량)이 많이 들기 때문에
소수점 이하까지 정확하게 계산할 게 아니라면
오른쪽 비트 이동 연산자를 사용하여 주로 처리한다.

## i 변수 값을 순서대로 1바이트씩 짤라서 변수에 넣고 16진수로 출력하는 법
& 0xff를 이용하라.
 
lang.ex05.Exam0440을 참조


## 조건문  : 흐름 제어문
표현식 : 문장을 실행한 뒤에 결과가 return 되는 식
비트 연산이 끝나면 그 값은 정수이기 때문에 조건식 안에 올 수 없다.
조건식은 무조건 true / false 값(boolean)이 나와야한다.

## if 조건문
문법1:
  if (조건) 문장1;
  => 조건이 참일 때 문장1을 수행한다.

문법2:
  if (조건) 문장1; else 문장2;
  => 조건이 참일 때 문장1을 수행하고, 거짓이면 문장2를 수행한다.
-여러 문장을 if 문에 종속시키고 싶으면 {} 블록으로 묶어라.

조건이 참일 경우와 참이 아닐 경우를 처리하는데 그 외를 처리할 때
if else 구문을 수행할 수 있다.

## if else 주의사항
-else 문만 단독으로 사용할 수 없다.
-if ~ else 사이에 다른 문장이 올 수 없다.
-else 는 가장 가까운 if문에 소속된다.
-else 문은 위에서 부터 실행한다.
-연속 if~ else 문장은 한 문장이기 때문에 블록으로 묶지 않아도 된다.

## swich 문
인트 값이나 문자열로 바로 판단하는 조건문
break; 문을 조절하여 반복할 구문을 조정할 수 있다.

switch (값) {}
값으로 가능한 데이터 타입은?
-int 정수(byte,short,int,char), 문자열, 특별한 상수 Enum 타입
-case 값으로 변수를 사용할 수 없다. 리터럴만 가능하다.
	case 1 * y: // 컴파일 오류!
-4바이트를 넘어가는 정수는 사용할 수 없다.
-부동소수점은 사용할 수 없다.
-boolean 값을 switch와 case에 사용할 수 없다.

-상수를 사용하지 않았을 때, 값의 의미를 주석으로 달아야만 다른 개발자가 이해할 수 있따.
	굳이 주석을 달지 않고, 상수를 이용할 수 있다. 그러면 주석 없이 바로 이해할 수 있다.
	case의 문자 값으로 변수를 사용할 수 없지만, 값이 변경되지 않는 final 변수라면 사용할 수 있다.

 ## 조건문 정리
1. if (조건) 문장;

1-2. if (조건) {
	문장;
	문장;
}


2. if (조건) 문장1;
else 문장2;


2-2. if (조건) {
	문장;
	문장;
}
else{
	문장;
	문장;
}

3. if 조건 {
	문장;
	문장;
} else if (조건) {
	문장;
	문장;
}else (조건) {
}


4. switch (값-int, String, enum) {
case 값1 : 
 	문장
	문장
break;
case 값2:
	문장
	문장
break;
default:
}


## 반복문
1. while (조건) 문장;

1-2. while (조건) {
	문장;
	문장;
}
0번 이상 반복
조건이 참인 동안 반복

2. do ~ while (조건);
2-2. do {
	문장;
	문장;
} while(조건);
1번 이상 반복


3. for (초기화; 조건; 증감) 문장;
3-2. for (초기화;조건;증감) {
	문장;
	문장;
	문장;
}
조건이 참인 동안 반복


4. for (변수 선언 : 배열, collection객체) {
	문장;
	문장;
}

## break; / continue;
while (조건) {
	문장;
	문장;
break;
	문장;
	문장;
}

실행중 break를 나가면 인접한 block(혹은 반복문) 으로부터 탈출한다.


while (조건) {
	문장;
	문장;
continue;
	문장;
	문장;
}

실행중 continue를 만나면 다음 문장을 실행하지 않고 조건 검사로 건너뛴다.

break; 시 myloop 라벨을 원하는 while문 구간에 주게되면
전체 while 문을 나간다.

## for 문 실행 순서
1. 변수 초기화
2. 조건
3. 문장
4. 변수 증가문
조건이 참인 동안 2 ~ 4를 반복한다.

for 문에서 선언한 변수는 블록변수로 for 문이 끝나면 i 는 없어진다.
for 문이 끝난 후 변수를 사용할 수 없다.

증감문을 넣지 않아도 된다.
문장 안에 증감을 넣어도 된다.

변수 선언도 앞으로 둘 수 있다.
하지만 문법 순서대로 세미 콜론을 입력해주어야 한다

int i= 1;
for (; i <=5;){
i++;
}
이런 경우 for 문이 끝나도 i를 조회할 수 있다.

변수 초기화 문장에 여러 변수를 선언할 수 있다.
증감문도 따로 변수마다 지정할 수 있다.

## 배열
배열의 처음부터 끝까지 값을 꺼내는 것이라면 다음의 for 문법을 사용하라! 아주 편하다!
for (배열에서 꺼낸 값을 저장할 변수 선언 : 배열주소) 문장;
for (String name : names)
      System.out.println(name);

## for (:)
- 배열 전체를 반복하거나 컬렉션(collection) 객체 전체를 반복할 때 유용한다.
- 배열의 일부만 반복할 수 없다.
- 배열의 값을 다룰 때 인덱스를 사용할 필요가 없어 편리하다.

문법:
for (변수 선언 : 배열, Iterable 구현체) 문장1;
for (변수 선언 : 배열, Iterable 구현체) { 문장1; 문장2; ...}
- 변수의 타입은 배열이나 Iterable 구현체의 항목 타입과 같아야 한다.
- 반복문을 돌 때 마다 항목을 값을 꺼내 변수에 담는다.



